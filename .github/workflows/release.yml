name: Release

on:
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        run: |
          git clone --depth 50 https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git .
          git fetch --tags
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version from package.json
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: notes
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            RANGE="HEAD"
          else
            RANGE="${LAST_TAG}..HEAD"
          fi

          {
            echo "notes<<EOF"

            FEATURES=$(git log $RANGE --pretty=format:"- %s" --grep="^feat" 2>/dev/null || true)
            if [ -n "$FEATURES" ]; then
              echo "## Features"
              echo "$FEATURES"
              echo ""
            fi

            FIXES=$(git log $RANGE --pretty=format:"- %s" --grep="^fix" 2>/dev/null || true)
            if [ -n "$FIXES" ]; then
              echo "## Bug Fixes"
              echo "$FIXES"
              echo ""
            fi

            REFACTORS=$(git log $RANGE --pretty=format:"- %s" --grep="^refactor" 2>/dev/null || true)
            if [ -n "$REFACTORS" ]; then
              echo "## Refactoring"
              echo "$REFACTORS"
              echo ""
            fi

            OTHERS=$(git log $RANGE --pretty=format:"- %s" --grep="^chore\|^docs\|^style\|^test" 2>/dev/null || true)
            if [ -n "$OTHERS" ]; then
              echo "## Other Changes"
              echo "$OTHERS"
            fi

            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Package packs as ZIPs
        run: |
          mkdir -p dist
          for dir in packs/*; do
            [ -d "$dir" ] || continue
            name=$(basename "$dir")
            (cd "$dir" && zip -r "../../dist/${name}.zip" .)
          done
          ls -l dist

      - name: Install manifest deps
        run: npm install yaml

      - name: Generate packs manifest
        env:
          RELEASE_TAG: ${{ steps.version.outputs.tag }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const crypto = require('crypto');
          const YAML = require('yaml');

          const distDir = path.join(process.cwd(), 'dist');
          const packsDir = path.join(process.cwd(), 'packs');
          const releaseTag = process.env.RELEASE_TAG || 'latest';

          const packs = [];

          for (const entry of fs.readdirSync(packsDir, { withFileTypes: true })) {
            if (!entry.isDirectory()) continue;
            const name = entry.name;
            const metaPath = path.join(packsDir, name, 'metadata.yaml');
            if (!fs.existsSync(metaPath)) continue;
            const meta = YAML.parse(fs.readFileSync(metaPath, 'utf8')) || {};
            const zipName = `${name}.zip`;
            const zipPath = path.join(distDir, zipName);
            const hash = fs.existsSync(zipPath)
              ? crypto.createHash('sha256').update(fs.readFileSync(zipPath)).digest('hex')
              : undefined;

            packs.push({
              id: name,
              name: meta.name || name,
              description: meta.summary || '',
              summary: meta.summary || '',
              version: meta.version || releaseTag,
              technology: meta.technology,
              license: meta.license,
              zip: zipName,
              checksum: hash ? `sha256:${hash}` : undefined
            });
          }

          const manifest = {
            version: releaseTag,
            generatedAt: new Date().toISOString(),
            packs
          };

          fs.writeFileSync(path.join(distDir, 'packs-manifest.json'), JSON.stringify(manifest, null, 2));
          console.log('Manifest written with', packs.length, 'packs');
          NODE

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"

          # Delete existing release if exists
          if gh release view "$TAG" >/dev/null 2>&1; then
            gh release delete "$TAG" -y
            git push origin :refs/tags/"$TAG" || true
          fi

          # Create release
          gh release create "$TAG" \
            dist/*.zip \
            dist/packs-manifest.json \
            --repo "$GITHUB_REPOSITORY" \
            --title "$TAG" \
            --notes "${{ steps.notes.outputs.notes }}" \
            --latest
